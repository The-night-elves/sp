package main

import (
	"flag"
	"fmt"
	"github.com/The-night-elves/sp/pkg/parse"
	"github.com/The-night-elves/sp/utils"
	"golang.org/x/tools/go/packages"
	"log"
	"os"
	"path/filepath"
	"strings"
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of sql_update_by_struct:\n")
	fmt.Fprintf(os.Stderr, "\tstringer [flags] -type 'struct_name1,struct_name2, ...'\n")
	//fmt.Fprintf(os.Stderr, "\tstringer [flags] -output  \n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	typeNames := flag.String("type", "", "comma-separated list of type names; must be set")
	//output := flag.String("output", "", "output file name; default srcdir/<type>.gen.go")
	flag.Usage = Usage
	flag.Parse()

	var dir string
	args := flag.Args()
	if len(args) == 0 {
		args = []string{"."}
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}

	cfg := &packages.Config{
		Mode: packages.LoadSyntax,
		// TODO: Need to think about constants in test files. Maybe write type_string_test.go
		// in a separate pass? For later.
		Tests: false,
	}

	pkg, err := packages.Load(cfg, args...)
	if err != nil {
		log.Fatal(err)
	} else if len(pkg) == 0 {
		log.Fatal("no packages found")
	}

	if *typeNames == "" {
		flag.Usage()
		os.Exit(2)
	}
	names := strings.Split(*typeNames, ",")
	filterName := make(map[string]struct{}, len(names))
	for i := 0; i < len(names); i++ {
		name := strings.TrimSpace(names[i])
		filterName[name] = struct{}{}
	}

	fmt.Println("generate typeNames:", names)
	sp := parse.Builder{}
	g := utils.Gen{}
	var baseName string
	for i, file := range pkg[0].Syntax {
		sp.ParseByAstFile(file)
		if i == 0 {
			g.Println("// Code generated by sql_update_by_struct DO NOT EDIT.\n")
			g.Printf("package %s\n\n", sp.Name)
			g.Println("\nimport (")
			g.Println("\t\"strconv\"")
			g.Println(")")
		}
		find := generate(&sp, &g, filterName)
		if baseName != "" {
			continue
		} else if find {
			// abst path /testdata/types.go
			_, fileName := filepath.Split(pkg[0].GoFiles[i])
			baseName, _, find = strings.Cut(fileName, ".go")
		}
	}

	// Write to file.
	outputName := filepath.Join(dir, fmt.Sprintf("%s.gen.go", baseName))
	err = os.WriteFile(outputName, g.Bytes(), 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

// generate generates the type and table name for the given type.
func generate(sp *parse.Builder, g *utils.Gen, filterName map[string]struct{}) (find bool) {
	for _, obj := range sp.Structs {
		_, ok := filterName[obj.Name]
		if !ok {
			continue
		}
		find = true
		var ident = strings.ToLower(string(obj.Name[0]))
		g.Println()
		g.Printf("func (%s *%s) Update() ([]string, []any) {\n", ident, obj.Name)
		g.Printf("\tcols := make([]string, 0, %d)\n", len(obj.Fields))
		g.Printf("\tvals := make([]any, 0, %d)\n", len(obj.Fields))
		g.Printf("\tvar index = 1\n")
		var index = 1
		for _, field := range obj.Fields {
			name := field.Name
			if name == "" {
				name = field.Kind
			}

			g.Printf("\tif %s.%s != nil {\n", ident, name)
			g.Printf("\t\tvals = append(vals, *%s.%s)\n", ident, name)

			key, ok := field.Tags["db"]
			if !ok {
				key = strings.ToLower(name)
			}
			g.Printf("\t\tcols = append(cols, \"%s=$\"+%s)\n", key, "strconv.Itoa(index)")
			g.Printf("\t\tindex++\n")
			index++

			g.Println("\t}")
		}
		g.Printf("\treturn cols, vals\n")
		g.Println("}")
	}
	return
}
